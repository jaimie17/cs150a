/*
 * Group Members: Samiyanur Islam and Jaimie Louie
 * PA2
 * Github Link: https://github.com/jaimie17/cs150a/blob/main/parser/parser.jj
 * we need Exp .length, Exp .id ( ExpList ), this., new int [Exp], new id (), !Exp, (Exp) and probably more
 */

options {
  IGNORE_CASE = false;
}

PARSER_BEGIN(MiniJavaParser)

import java.io.*;

public class MiniJavaParser {

  public static void main(String[] args) throws ParseException {
    BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
    Token temp_token = null;

    SimpleCharStream stream = new SimpleCharStream(reader);
    MiniJavaParserTokenManager TkMgr = new MiniJavaParserTokenManager(stream);
    
    // Tells us whether the program is valid or not
    MiniJavaParser parser = new MiniJavaParser(TkMgr);
    boolean valid = false;
    try {
        parser.Program();
        valid = true;
    } catch (ParseException e) {
        System.out.println("Program is not valid: " + e.getMessage());
    }

    if (valid) {
        System.out.println("Program is valid.");
    } else {
        System.out.println("Program is not valid.");
}
  }
}

PARSER_END(MiniJavaParser)

SKIP: /* Whitespace */
{
  "\t"
| "\n"
| "\r"
| " "
}

TOKEN:
{
   <CLASS: "class" >
|  <PUBLIC: "public" >
|  <STATIC: "static" >
|  <VOID: "void" >
|  <NEW: "new" >
|  <MAIN: "main" >
|  <STRING: "String" >
|  <EXTENDS: "extends" >
|  <RETURN: "return" >
|  <BOOLEAN: "boolean" >
|  <INT: "int" >
|  <IF: "if" >
|  <ELSE: "else" >
|  <WHILE: "while" >
|  <PRINT: "System.out.print" >
|  <STRING_LITERAL: "\"" (~["\r", "\n", "\""])* "\"" >
|  <EQUAL: "=" >
|  <LPAREN: "(" >
|  <RPAREN: ")" >
|  <LBRACKET: "[">
|  <RBRACKET: "]" >
|  <SEMICOLON: ";" >
|  <ADD_OP: "+" >
|  <MINUS_OP: "-" >
|  <MULT_OP: "*" >
|  <DIV_OP: "/" >
|  <LENGTH: "length" >
|  <DOT: "." >
|  <NUMBER: (["0"-"9"])+ > 
|  <TRUE: "true" >
|  <FALSE: "false" >
|  <THIS: "this" >
|  <NOT: "!" >
|  <COMMA: "," >
|  <LBRACE: "{" >
|  <RBRACE: "}" >
|  <LESS_THAN: "<" >
|  <GREATER_THAN: ">" >
|  <EQUALS: "==" >
|  <NOT_EQUALS: "!=" >
|  <AND: "&&" >
|  <OR: "||" >
|  <LESS_THAN_OR_EQUAL: "<=" >
|  <GREATER_THAN_OR_EQUAL: ">=" >
|  <INCREMENT: "++" >
|  <DECREMENT: "--" >
|  <PLUS_EQUAL: "+=" >
|  <MINUS_EQUAL: "-=" >
|  <MULT_EQUAL: "*=" >
|  <DIV_EQUAL: "/=" >
|  <ID: ["a"-"z","A"-"Z","_"] (["a"-"z","A"-"Z","_","0"-"9"])* >
|  <SINGLE_LINE_COMMENT: "//" (~["\n", "\r"])* ("\n" | "\r" | "\r\n")? >
|  <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/" >
|  <ERROR: ~[] >
}

/*
 * Parser grammar rules
 */
void Program(): 
{}
{
    ( ClassDeclaration() )*
}

void ClassDeclaration(): 
{}
{
    <CLASS> <ID> ( <EXTENDS> <ID> )? <LBRACE>
        ( VarDeclaration() )*
        ( MethodDeclaration() )*
    <RBRACE>
}

void VarDeclaration(): 
{}
{
    Type() (<ID> | <TRUE> | <FALSE>) <SEMICOLON>
}

void MethodDeclaration(): 
{}
{
    <PUBLIC> Type() <ID> <LPAREN> ( Type() <ID> ( <COMMA> Type() <ID> )* )? <RPAREN> <LBRACE>
        ( VarDeclaration() )*
        ( Statement() )*
        <RETURN> Exp() <SEMICOLON>
    <RBRACE>
}

void Type(): 
{}
{
    <INT>
  | <BOOLEAN>
  | <VOID>
}

void Statement(): 
{}
{
    IfStatement()
  | WhileStatement()
  | PrintStatement()
  | AssignmentStatement()
}

void IfStatement():
{}
{
    <IF> <LPAREN> Exp() <RPAREN> Statement() <ELSE> Statement()
}

void WhileStatement():
{}
{
    <WHILE> <LPAREN> Exp() <RPAREN> Statement()
}

void PrintStatement():
{}
{
    <PRINT> <LPAREN> Exp() <RPAREN> <SEMICOLON>
}

void AssignmentStatement():
{}
{
    <ID> AssignmentStatementA()
}

void AssignmentStatementA():
{}
{
   <LBRACKET> Exp() <RBRACKET> <EQUAL> Exp() <SEMICOLON>
    |
    <EQUAL> Exp() <SEMICOLON>
}

/* Arithmetic Expression Grammar */

void Exp():
{}
{
    Exp9()
}

void Exp9():
{}
{ 
  Exp10() Exp9a()
}

void Exp9a():
{}
{
  <ADD_OP> Exp10() { /* Build AST or process the operator here */ } Exp9a()
  |
  <MINUS_OP> Exp10() { /* Build AST or process the operator here */ } Exp9a()
  |
  {}  
}

void Exp10():
{}
{ 
  Exp11() Exp10a()
}

void Exp10a():
{}
{
  <LESS_THAN> Exp11() { /* Build AST or process the operator here */ } Exp10a()
  |
  {}  
}

void Exp11():
{}
{ 
  Exp12() Exp11a()
}

void Exp11a():
{}
{
  <MULT_OP> Exp12(){ /* Build AST or process the operator here */ } Exp11a()
  |
  <DIV_OP> Exp12(){ /* Build AST or process the operator here */ } Exp11a()
  |
  {} 
}

void Exp12():
{}
{ 
  Exp13() ( <AND> Exp13() { /* Build AST or process the operator here */ } )?
}

void Exp13():
{}
{
  Exp16() ( <LBRACKET> Exp() <RBRACKET> { /* Build AST or process the operator here */ } | <DOT> <LENGTH> { /* Build AST or process the operator here */ } )?
}

void Exp16():
{ Token t;}
{
  t=<NUMBER> { /* Build AST or process the token here */ }
  |
  t=<ID> { /* Build AST or process the token here */ }
  |
  <LPAREN> Exp() <RPAREN>
}
