/*
 * Group Members: Samiyanur Islam and Jaimie Louie
 * PA2
 * Github Link: https://github.com/jaimie17/cs150a/blob/main/parser/parser.jj
 */

options {
  IGNORE_CASE = false;
}

PARSER_BEGIN(MiniJavaLex)

import java.io.*;

public class MiniJavaLex {

  public static void main(String[] args) throws ParseException {
    BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
    Token temp_token = null;

    SimpleCharStream stream = new SimpleCharStream(reader);
    MiniJavaLexTokenManager TkMgr = new MiniJavaLexTokenManager(stream);
    
    // so it tells us whether its valid or not
    MiniJavaParser parser = new MiniJavaParser(TkMgr);
    try {
        parser.Program();
        System.out.println("Program is valid.");
    } catch (ParseException e) {
        System.out.println("Program is not valid: " + e.getMessage());
    }

    do {
    temp_token = TkMgr.getNextToken();

    switch(temp_token.kind) {
        case CLASS: System.out.println("CLASS: " + temp_token.image);
            break;
        case PUBLIC: System.out.println("PUBLIC: " + temp_token.image);
            break;
        case STATIC: System.out.println("STATIC: " + temp_token.image);
            break;
        case VOID: System.out.println("VOID: " + temp_token.image);
            break;
        case NEW: System.out.println("NEW: " + temp_token.image);
            break;
        case MAIN: System.out.println("MAIN: " + temp_token.image);
            break;
        case STRING: System.out.println("STRING: " + temp_token.image);
            break;
        case EXTENDS: System.out.println("EXTENDS: " + temp_token.image);
            break;
        case RETURN: System.out.println("RETURN: " + temp_token.image);
            break;
        case BOOLEAN: System.out.println("BOOLEAN: " + temp_token.image);
            break;
        case INT: System.out.println("INT: " + temp_token.image);
            break;
        case ID: System.out.println("ID: " + temp_token.image);
            break;
        case IF: System.out.println("IF: " + temp_token.image);
            break;
        case ELSE: System.out.println("ELSE: " + temp_token.image);
            break;
        case WHILE: System.out.println("WHILE: " + temp_token.image);
            break;
        case PRINT: System.out.println("PRINT: " + temp_token.image);
            break;
        case STRING_LITERAL: System.out.println("STRING_LITERAL: " + temp_token.image);
            break;
        case EQUAL: System.out.println("EQUAL: " + temp_token.image);
            break;
        case LPAREN: System.out.println("LPAREN: " + temp_token.image);
            break;
        case RPAREN: System.out.println("RPAREN: " + temp_token.image);
            break;
        case LBRACKET: System.out.println("LBRACKET: " + temp_token.image);
            break;
        case RBRACKET: System.out.println("RBRACKET: " + temp_token.image);
            break;
        case SEMICOLON: System.out.println("SEMICOLON: " + temp_token.image);
            break;
        case ADD_OP: System.out.println("ADD_OP: " + temp_token.image);
            break;
        case MINUS_OP: System.out.println("MINUS_OP: " + temp_token.image);
            break;
        case MULT_OP: System.out.println("MULT_OP: " + temp_token.image);
            break;
        case DIV_OP: System.out.println("DIV_OP: " + temp_token.image);
            break;
        case LENGTH: System.out.println("LENGTH: " + temp_token.image);
            break;
        case DOT: System.out.println("DOT: " + temp_token.image);
            break;
        case NUMBER: System.out.println("NUMBER: " + temp_token.image);
            break;
        case TRUE: System.out.println("TRUE: " + temp_token.image);
            break;
        case FALSE: System.out.println("FALSE: " + temp_token.image);
            break;
        case THIS: System.out.println("THIS: " + temp_token.image);
            break;
        case NOT: System.out.println("NOT: " + temp_token.image);
            break;
        case COMMA: System.out.println("COMMA: " + temp_token.image);
            break;
        case LBRACE: System.out.println("LBRACE: " + temp_token.image);
            break;
        case RBRACE: System.out.println("RBRACE: " + temp_token.image);
            break;
        case LESS_THAN: System.out.println("LESS_THAN: " + temp_token.image);
            break;
        case GREATER_THAN: System.out.println("GREATER_THAN: " + temp_token.image);
            break;
        case EQUALS: System.out.println("EQUALS: " + temp_token.image);
            break;
        case NOT_EQUALS: System.out.println("NOT_EQUALS: " + temp_token.image);
            break;
        case AND: System.out.println("AND: " + temp_token.image);
            break;
        case OR: System.out.println("OR: " + temp_token.image);
            break;
        case LESS_THAN_OR_EQUAL: System.out.println("LESS_THAN_OR_EQUAL: " + temp_token.image);
            break;
        case GREATER_THAN_OR_EQUAL: System.out.println("GREATER_THAN_OR_EQUAL: " + temp_token.image);
            break;
        case INCREMENT: System.out.println("INCREMENT: " + temp_token.image);
            break;
        case DECREMENT: System.out.println("DECREMENT: " + temp_token.image);
            break;
        case PLUS_EQUAL: System.out.println("PLUS_EQUAL: " + temp_token.image);
            break;
        case MINUS_EQUAL: System.out.println("MINUS_EQUAL: " + temp_token.image);
            break;
        case MULT_EQUAL: System.out.println("MULT_EQUAL: " + temp_token.image);
            break;
        case DIV_EQUAL: System.out.println("DIV_EQUAL: " + temp_token.image);
            break;
        case SINGLE_LINE_COMMENT:System.out.println("SINGLE_LINE_COMMENT: " + temp_token.image);
            break;
        case MULTI_LINE_COMMENT:System.out.println("MULTI_LINE_COMMENT: " + temp_token.image);
            break;
        case ERROR: System.out.println("ERROR: " + temp_token.image);
            break;
        default:
            if (temp_token.kind != EOF)
                System.out.println("OTHER: " + temp_token.image);
            break;
        }
    } while (temp_token.kind != EOF);
  }
}

PARSER_END(MiniJavaLex)

SKIP: /* Whitespace */
{
  "\t"
| "\n"
| "\r"
| " "
}

TOKEN:
{
   <CLASS: "class" >
|  <PUBLIC: "public" >
|  <STATIC: "static" >
|  <VOID: "void" >
|  <NEW: "new" >
|  <MAIN: "main" >
|  <STRING: "String" >
|  <EXTENDS: "extends" >
|  <RETURN: "return" >
|  <BOOLEAN: "boolean" >
|  <INT: "int" >
|  <IF: "if" >
|  <ELSE: "else" >
|  <WHILE: "while" >
|  <PRINT: "System.out.print" >
|  <STRING_LITERAL: "\"" (~["\r", "\n", "\""])* "\"" >
|  <EQUAL: "=" >
|  <LPAREN: "(" >
|  <RPAREN: ")" >
|  <LBRACKET: "[">
|  <RBRACKET: "]" >
|  <SEMICOLON: ";" >
|  <ADD_OP: "+" >
|  <MINUS_OP: "-" >
|  <MULT_OP: "*" >
|  <DIV_OP: "/" >
|  <LENGTH: "length" >
|  <DOT: "." >
|  <NUMBER: (["0"-"9"])+ > 
|  <TRUE: "true" >
|  <FALSE: "false" >
|  <THIS: "this" >
|  <NOT: "!" >
|  <COMMA: "," >
|  <LBRACE: "{" >
|  <RBRACE: "}" >
|  <LESS_THAN: "<" >
|  <GREATER_THAN: ">" >
|  <EQUALS: "==" >
|  <NOT_EQUALS: "!=" >
|  <AND: "&&" >
|  <OR: "||" >
|  <LESS_THAN_OR_EQUAL: "<=" >
|  <GREATER_THAN_OR_EQUAL: ">=" >
|  <INCREMENT: "++" >
|  <DECREMENT: "--" >
|  <PLUS_EQUAL: "+=" >
|  <MINUS_EQUAL: "-=" >
|  <MULT_EQUAL: "*=" >
|  <DIV_EQUAL: "/=" >
|  <ID: ["a"-"z","A"-"Z","_"] (["a"-"z","A"-"Z","_","0"-"9"])* >
|  <SINGLE_LINE_COMMENT: "//" (~["\n", "\r"])* ("\n" | "\r" | "\r\n")? >
|  <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/" >
|  <ERROR: ~[] >
}

/*
 * Parser grammar rules
 */
void Program(): 
{}
{
    ( ClassDeclaration() )*
}

void ClassDeclaration(): 
{}
{
    <CLASS> <ID> ( <EXTENDS> <ID> )? <LBRACE>
        ( VarDeclaration() )*
        ( MethodDeclaration() )*
    <RBRACE>
}

void VarDeclaration(): 
{}
{
    Type() (<ID> | <TRUE> | <FALSE>) <SEMICOLON>
}

void MethodDeclaration(): 
{}
{
    <PUBLIC> Type() <ID> <LPAREN> ( Type() <ID> ( <COMMA> Type() <ID> )* )? <RPAREN> <LBRACE>
        ( VarDeclaration() )*
        ( Statement() )*
        <RETURN> Exp() <SEMICOLON>
    <RBRACE>
}

void Type(): 
{}
{
    <INT>
  | <BOOLEAN>
  | <VOID>
  | <ID>
}

void Statement(): 
{}
{
    IfStatement()
  | WhileStatement()
  | PrintStatement()
  | AssignmentStatement()
  | ArrayAssignmentStatement()
}

void IfStatement():
{}
{
    <IF> <LPAREN> Exp() <RPAREN> Statement() <ELSE> Statement()
}

void WhileStatement():
{}
{
    <WHILE> <LPAREN> Exp() <RPAREN> Statement()
}

void PrintStatement():
{}
{
    <PRINT> <LPAREN> Exp() <RPAREN> <SEMICOLON>
}

void AssignmentStatement():
{}
{
    <ID> <EQUAL> Exp() <SEMICOLON>
}

void ArrayAssignmentStatement():
{}
{
    <ID> <LBRACKET> Exp() <RBRACKET> <EQUAL> Exp() <SEMICOLON>
}

/* Arithmetic Expression Grammar */

void Exp():
{}
{
    Exp9()
}

void Exp9():
{}
{ 
  Exp10() Exp9a()
}

void Exp9a():
{}
{
  <ADD_OP> Exp10() { /* Build AST or process the operator here */ } Exp9a()
  |
  <MINUS_OP> Exp10() { /* Build AST or process the operator here */ } Exp9a()
  |
  {}  
}

void Exp10():
{}
{ 
  Exp11() Exp10a()
}

void Exp10a():
{}
{
  <LESS_THAN> Exp11() { /* Build AST or process the operator here */ } Exp10a()
  |
  {}  
}

void Exp11():
{}
{ 
  Exp12() Exp11a()
}

void Exp11a():
{}
{
  <MULT_OP> Exp12(){ /* Build AST or process the operator here */ } Exp11a()
  |
  <DIV_OP> Exp12(){ /* Build AST or process the operator here */ } Exp11a()
  |
  {} 
}

void Exp12():
{}
{ 
  Exp13() ( <AND> Exp13() { /* Build AST or process the operator here */ } )?
}

void Exp13():
{}
{
  Exp16() ( <LBRACKET> Exp() <RBRACKET> { /* Build AST or process the operator here */ } | <DOT> <LENGTH> { /* Build AST or process the operator here */ } )?
}

void Exp16():
{ Token t;}
{
  t=<NUMBER> { /* Build AST or process the token here */ }
  |
  t=<ID> { /* Build AST or process the token here */ }
  |
  <LPAREN> Exp() <RPAREN>
}

// we need Exp .length, Exp .id ( ExpList ), this., new int [Exp], new id (), !Exp, (Exp) and probably more